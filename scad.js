export function buildScadCode(balls, threshold) {
  const iso = Number.isFinite(threshold) ? threshold : 1;
  const specEntries = [];
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  let sumRadius = 0;
  let maxRadius = 0;

  balls.forEach((ball, index) => {
    const { x, y, z, r } = ball;
    sumRadius += r;
    maxRadius = Math.max(maxRadius, r);

    minX = Math.min(minX, x - r);
    maxX = Math.max(maxX, x + r);
    minY = Math.min(minY, y - r);
    maxY = Math.max(maxY, y + r);
    minZ = Math.min(minZ, z - r);
    maxZ = Math.max(maxZ, z + r);

    const fallbackName = `Ball ${index + 1}`;
    const label = typeof ball.name === 'string' && ball.name.trim() ? ball.name.trim() : fallbackName;
    const safeLabel = label.replace(/\r?\n/g, ' ');
    specEntries.push(
      `    // ${safeLabel}\n    move([${x.toFixed(2)}, ${y.toFixed(2)}, ${z.toFixed(2)}]), mb_sphere(${r.toFixed(2)})`
    );
  });

  if (balls.length === 0) {
    minX = minY = minZ = -50;
    maxX = maxY = maxZ = 50;
    maxRadius = 25;
  }

  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;
  const cz = (minZ + maxZ) / 2;

  let hx = (maxX - minX) / 2;
  let hy = (maxY - minY) / 2;
  let hz = (maxZ - minZ) / 2;

  if (!Number.isFinite(hx) || hx <= 0) hx = maxRadius || 10;
  if (!Number.isFinite(hy) || hy <= 0) hy = maxRadius || 10;
  if (!Number.isFinite(hz) || hz <= 0) hz = maxRadius || 10;

  hx = Math.max(hx, maxRadius);
  hy = Math.max(hy, maxRadius);
  hz = Math.max(hz, maxRadius);

  const inflate = 1.75;
  minX = cx - hx * inflate;
  maxX = cx + hx * inflate;
  minY = cy - hy * inflate;
  maxY = cy + hy * inflate;
  minZ = cz - hz * inflate;
  maxZ = cz + hz * inflate;

  const baseVoxel = 10;
  const n = Math.max(1, balls.length);
  const avgRadius = balls.length ? sumRadius / balls.length : baseVoxel;
  const complexity = n * (avgRadius / 60);
  let voxelSize = baseVoxel * (1 + 0.25 * (complexity - 1));
  voxelSize = Math.max(5, Math.min(voxelSize, 40));

  let code = '';
  code += '// Generated by metaball_editor\n';
  code += '// Include BOSL2 libraries providing metaballs and transformations\n';
  code += 'include <BOSL2/std.scad>\n';
  code += 'include <BOSL2/isosurface.scad>\n\n';

  code += '// Define metaball specification using transformations and built-in metaball primitives.\n';
  code += 'spec = [\n';
  code += specEntries.join(',\n');
  if (specEntries.length) code += '\n';
  code += '];\n\n';

  code += '// Bounding box surrounds all metaballs with extra padding to avoid clipping.  Adjust if needed.\n';
  code += `bounding_box = [[${minX.toFixed(2)}, ${minY.toFixed(2)}, ${minZ.toFixed(2)}], `;
  code += `[${maxX.toFixed(2)}, ${maxY.toFixed(2)}, ${maxZ.toFixed(2)}]];\n\n`;

  code += '// Voxel size controls resolution; smaller values give smoother surfaces but take longer.\n';
  code += `voxel_size = ${voxelSize.toFixed(2)};\n`;
  code += `isovalue = ${iso.toFixed(2)};\n\n`;

  code += '// Render the metaballs using named parameters.\n';
  code += 'metaballs(\n';
  code += '    spec=spec,\n';
  code += '    bounding_box=bounding_box,\n';
  code += '    voxel_size=voxel_size,\n';
  code += '    isovalue=isovalue\n';
  code += ');\n';

  return code;
}

export function parseScadCode(text) {
  if (typeof text !== 'string') return null;
  const balls = [];
  const specMatch = text.match(/spec\s*=\s*\[(.*?)\];/is);
  if (specMatch) {
    const body = specMatch[1];
    const entryRegex = /(\/\/[^\n\r]*\s*)?move\(\[([^\]]+)\]\)\s*,\s*mb_sphere\(([^)]+)\)/gi;
    let match;
    let entryIndex = 0;
    while ((match = entryRegex.exec(body))) {
      entryIndex += 1;
      const comment = match[1] || '';
      const coords = match[2].split(',').map(part => parseFloat(part));
      const radius = parseFloat(match[3]);
      if (coords.length < 3 || coords.some(n => !Number.isFinite(n)) || !Number.isFinite(radius)) continue;
      const name = comment.replace('//', '').trim();
      balls.push({
        x: coords[0],
        y: coords[1],
        z: coords[2],
        r: Math.max(1, radius),
        name: name || `Ball ${entryIndex}`
      });
    }
  }

  const isoMatch = text.match(/isovalue\s*=\s*([^;]+)/i);
  const threshold = isoMatch ? parseFloat(isoMatch[1]) : null;

  return {
    balls,
    threshold: Number.isFinite(threshold) ? threshold : null
  };
}
